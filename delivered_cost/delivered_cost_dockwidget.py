# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DeliveredCostDockWidget
                                 A QGIS plugin
 This plugin provides delivered cost for an area of interest.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Tim
        email                : timothy.vandriel@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import (
    QgsProject,
    QgsRasterLayer,
    Qgis,
    QgsMessageLog,
    QgsRectangle,
    QgsVectorLayer,
    QgsFeature,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsGeometry,
    QgsPointXY,
    QgsRasterShader,
    QgsColorRampShader,
    QgsSingleBandPseudoColorRenderer,
    QgsRasterBandStats,
    QgsMarkerSymbol,
)
from qgis.gui import QgsMapToolPan, QgsVertexMarker
from qgis.utils import iface
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QInputDialog, QApplication
from PyQt5.QtCore import QTimer, Qt, QThreadPool
from .draw_polygon_tool import DrawPolygonTool
from .pick_point_tool import PickPointTool
from PyQt5.QtGui import QColor


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "delivered_cost_dockwidget_base.ui")
)


class DeliveredCostDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(DeliveredCostDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.threadpool = QThreadPool.globalInstance()
        self.plainTextEdit.setReadOnly(True)
        # Manage the OSM layer
        self.osm_layer_id = None
        QgsProject.instance().layerWillBeRemoved.connect(self.on_layer_removed)
        iface.actionPan().trigger()

        # Background layers
        self.layer_configs = {
            self.esriCheckBox: {
                "name": "ESRI World Imagery",
                "url": "type=xyz&zmin=0&zmax=19&url=https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                "provider": "wms",
                "layer_id": None,
            },
            self.burnProbCheckBox: {
                "name": "Burn Probability",
                "url": "url=https://apps.fs.usda.gov/fsgisx03/rest/services/wo_spf_fam/Nat_BurnProbability/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
            self.evtCheckBox: {
                "name": "EVT",
                "url": "url=https://lfps.usgs.gov/arcgis/rest/services/Landfire_LF230/US_230EVT/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
            self.pctCheckBox: {
                "name": "PCL",
                "url": "url=https://apps.fs.usda.gov/fsgisx03/rest/services/wo_spf_fam/Potential_Control_Location/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
        }

        for checkbox in self.layer_configs.keys():
            checkbox.toggled.connect(self.on_layer_checkbox_toggled)

        # Connect sliders to spinboxes
        self.rtSkidderSpeedSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.rtSkidderSpeedSlider, self.rtSpdSpinBox
            )
        )
        self.rtSpdSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.rtSpdSpinBox, self.rtSkidderSpeedSlider
            )
        )
        self.skylineSpeedSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.skylineSpeedSlider, self.skylineSpdSpinBox
            )
        )
        self.skylineSpdSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.skylineSpdSpinBox, self.skylineSpeedSlider
            )
        )
        self.rtSkidderMonSlider.valueChanged.connect(self.rtSkidderMonSpinBox.setValue)
        self.rtSkidderMonSpinBox.valueChanged.connect(
            lambda val: self.rtSkidderMonSlider.setValue(int(val))
        )

        self.skylineMonSlider.valueChanged.connect(self.skylineMonSpinBox.setValue)
        self.skylineMonSpinBox.valueChanged.connect(
            lambda val: self.skylineMonSlider.setValue(int(val))
        )

        self.fellerbuncherRateSlider.valueChanged.connect(
            self.fellerbunchRateSpinBox.setValue
        )
        self.fellerbunchRateSpinBox.valueChanged.connect(
            lambda val: self.fellerbuncherRateSlider.setValue(int(val))
        )

        self.handFellingSlider.valueChanged.connect(
            self.handfellingRateSpinBox.setValue
        )
        self.handfellingRateSpinBox.valueChanged.connect(
            lambda val: self.handFellingSlider.setValue(int(val))
        )

        self.processingSlider.valueChanged.connect(self.processingSpinBox.setValue)
        self.processingSpinBox.valueChanged.connect(
            lambda val: self.processingSlider.setValue(int(val))
        )

        self.haulingSlider.valueChanged.connect(self.haulingSpinBox.setValue)
        self.haulingSpinBox.valueChanged.connect(
            lambda val: self.haulingSlider.setValue(int(val))
        )

        self.handTreatmentSlider.valueChanged.connect(
            self.handTreatmentSpinBox.setValue
        )
        self.handTreatmentSpinBox.valueChanged.connect(
            lambda val: self.handTreatmentSlider.setValue(int(val))
        )

        self.prescribedFireSlider.valueChanged.connect(
            self.prescribedFireSpinBox.setValue
        )
        self.prescribedFireSpinBox.valueChanged.connect(
            lambda val: self.prescribedFireSlider.setValue(int(val))
        )

        self.rtSkidderPayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.rtSkidderPayloadSlider, self.rtSkidderPayloadSpinBox
            )
        )
        self.rtSkidderPayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.rtSkidderPayloadSpinBox, self.rtSkidderPayloadSlider
            )
        )
        self.skylinePayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.skylinePayloadSlider, self.skylinePayloadSpinBox
            )
        )
        self.skylinePayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.skylinePayloadSpinBox, self.skylinePayloadSlider
            )
        )
        self.logTruckPayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.logTruckPayloadSlider, self.logTruckPayloadSpinBox
            )
        )
        self.logTruckPayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.logTruckPayloadSpinBox, self.logTruckPayloadSlider
            )
        )
        # Initialize the draw polygon tool
        self.drawTool = DrawPolygonTool(iface.mapCanvas())
        self.drawTool.polygonCompleted.connect(self.handle_polygon_completed)
        self.drawPolygonButton.clicked.connect(self.activate_draw_tool)

        # Initialize pick point tool
        self.pointTool = PickPointTool(iface.mapCanvas())
        self.pointTool.pointPicked.connect(self.handle_point_picked)
        self.pickPointButton.clicked.connect(self.activate_point_picker)
        self.facility_coords = []  # Store picked point coordinates
        self.facility_layer = None

        # Connect shapefile selection buttons
        self.userRoadsButton.clicked.connect(self.select_roads_shapefile)
        self.userBarriersButton.clicked.connect(self.select_barriers_shapefile)

        # Connect run button
        self.runButton.clicked.connect(self.run_delivered_cost)

    def update_spinbox_from_slider(self, slider, spinbox):
        spinbox.setValue(slider.value() / 10.0)

    def update_slider_from_spinbox(self, spinbox, slider):
        slider.setValue(int(spinbox.value() * 10))

    def add_osm_basemap(self):
        if getattr(self, "osm_layer_id", None) is None:
            layer_name = "OSM Standard"
            url = "type=xyz&zmin=0&zmax=19&url=http://tile.openstreetmap.org/{z}/{x}/{y}.png"
            layer = QgsRasterLayer(url, layer_name, "wms")
            if layer.isValid():
                QgsProject.instance().addMapLayer(layer, addToLegend=False)
                QgsProject.instance().layerTreeRoot().insertLayer(0, layer)
                self.osm_layer_id = (
                    layer.id()
                )  # Store only the layer ID, not the layer object
            else:
                QMessageBox.critical(
                    None,
                    "Layer Load Error",
                    f"Failed to load layer: {layer_name}. Please check the URL.",
                )

    def on_layer_removed(self, layer_id):
        if getattr(self, "osm_layer_id", None) == layer_id:
            self.osm_layer_id = None
        if self.facility_layer_id == layer_id:
            self.facility_layer_id = None
            self.facility_coords = []
            self.facility_layer = None

    def zoom_to_us_extent_3857(self):
        # Approximate extent for continental U.S. in EPSG:3857 (Web Mercator)
        extent_3857 = QgsRectangle(-14000000, 2800000, -7000000, 6300000)

        # Set extent and refresh canvas
        canvas = iface.mapCanvas()
        canvas.setExtent(extent_3857)
        canvas.refresh()

    def on_layer_checkbox_toggled(self, checked):
        checkbox = self.sender()  # Which checkbox sent this signal?
        config = self.layer_configs.get(checkbox)
        if config is None:
            return

        if checked:
            # Add layer if not already added
            if not config["layer_id"]:
                layer = QgsRasterLayer(
                    config["url"], config["name"], config["provider"]
                )
                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    config["layer_id"] = layer.id()
                else:
                    QMessageBox.critical(
                        None,
                        "Layer Load Error",
                        f"Failed to load layer: {config['name']}",
                    )
        else:
            # Remove layer if exists
            layer_id = config.get("layer_id")
            if layer_id:
                layer = QgsProject.instance().mapLayer(layer_id)
                if layer:
                    QgsProject.instance().removeMapLayer(layer)
                    iface.mapCanvas().refresh()
                config["layer_id"] = None

    def activate_draw_tool(self):
        # If AOI layer already exists, remove it from project
        if hasattr(self, "aoi_layer_id") and self.aoi_layer_id:
            layer = QgsProject.instance().mapLayer(self.aoi_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.aoi_layer_id = None
            iface.mapCanvas().refresh()

        # Set up and activate the drawing tool
        iface.mapCanvas().setMapTool(self.drawTool)

        # Show instructions
        iface.messageBar().pushMessage(
            "Instructions for drawing a polygon",
            "Click to add points, right-click to finish the polygon. AOI will be removed if button is clicked again.",
            level=Qgis.Info,
            duration=25,
        )

    def handle_polygon_completed(self, geom):
        project_crs = QgsProject.instance().crs()
        geom = QgsGeometry(geom)
        self.aoi_geometry = geom

        # Create the layer
        aoi_layer = QgsVectorLayer(
            f"Polygon?crs={project_crs.authid()}", "AOI", "memory"
        )
        QgsProject.instance().addMapLayer(aoi_layer)
        self.aoi_layer_id = aoi_layer.id()  # Store only the ID

        pr = aoi_layer.dataProvider()
        feat = QgsFeature()
        feat.setGeometry(geom)
        pr.addFeatures([feat])
        aoi_layer.updateExtents()
        aoi_layer.triggerRepaint()
        iface.mapCanvas().refresh()

        iface.actionPan().trigger()

    def activate_point_picker(self):
        if self.facility_layer is None:
            # Create a memory layer for facility points
            crs = QgsProject.instance().crs()
            self.facility_layer = QgsVectorLayer(
                f"Point?crs={crs.authid()}", "Facilities", "memory"
            )
            QgsProject.instance().addMapLayer(self.facility_layer)
            self.facility_layer_id = self.facility_layer.id()

            # Apply black dot symbology
            symbol = QgsMarkerSymbol.createSimple(
                {
                    "name": "circle",
                    "color": "black",
                    "size": "3",
                }
            )
            self.facility_layer.renderer().setSymbol(symbol)
            self.facility_layer.triggerRepaint()

        iface.mapCanvas().setMapTool(self.pointTool)

        iface.messageBar().pushMessage(
            "Instructions for picking multiple points",
            "Click to add a facility location. Repeat as needed. Delete 'Facilities' layer to start over.",
            level=Qgis.Info,
            duration=20,
        )

    def handle_point_picked(self, point):
        self.facility_coords.append((point.x(), point.y()))
        geom = QgsGeometry.fromPointXY(point)

        # Add the new point to the same memory layer
        provider = self.facility_layer.dataProvider()
        feat = QgsFeature()
        feat.setGeometry(geom)
        provider.addFeatures([feat])
        self.facility_layer.updateExtents()
        self.facility_layer.triggerRepaint()
        iface.mapCanvas().refresh()

    def select_roads_shapefile(self):
        filename, _ = QFileDialog.getOpenFileName(
            self, "Select User Specified Roads Shapefile", "", "Shapefiles (*.shp)"
        )
        if filename:
            self.userRoadsLineEdit.setText(filename)
            self.lyr_roads_path = filename

    def select_barriers_shapefile(self):
        filename, _ = QFileDialog.getOpenFileName(
            self, "Select User Specified Barriers Shapefile", "", "Shapefiles (*.shp)"
        )
        if filename:
            self.userBarriersLineEdit.setText(filename)
            self.lyr_barriers_path = filename

    def log_to_textbox(self, message):
        self.plainTextEdit.appendPlainText(str(message))

    def handle_results(self, result_dict):

        self.log_to_textbox("Delivered Cost Analysis completed successfully.")
        self.runButton.setEnabled(True)
        try:
            for name, dest_path in result_dict.items():
                layer = QgsRasterLayer(dest_path, name)
                layer.setCustomProperty("delivered_cost_plugin/temp", True)

                # Ensure the raster layer is valid
                if not layer.isValid():
                    raise RuntimeError("Raster layer failed to load.")

                # Trigger stats computation so QGIS knows actual min/max values
                provider = layer.dataProvider()
                stats = provider.bandStatistics(1, QgsRasterBandStats.All)
                min_val = stats.minimumValue
                max_val = stats.maximumValue

                # Now apply symbology AFTER stats are known
                if (
                    "delivered" in name.lower()
                    or "skidder" in name.lower()
                    or "cable" in name.lower()
                ):
                    if max_val > 1000:
                        self.log_to_textbox(
                            f"Applying capped symbology to {name} with max value 1000"
                        )
                        apply_capped_symbology(layer, cap_value=1000)
                    else:
                        self.log_to_textbox(
                            f"Applying uncapped symbology to {name} with max value {max_val}"
                        )
                        apply_capped_symbology(layer, cap_value=max_val)

                QgsProject.instance().addMapLayer(layer)
        except Exception as e:
            self.log_to_textbox(f"Error adding layers to project: {str(e)}")

    def show_error(self, error_message):
        self.log_to_textbox(f"Error: {error_message}")
        QMessageBox.critical(self, "Error", error_message)
        self.runButton.setEnabled(True)

    def run_delivered_cost(self):
        self.plainTextEdit.clear()
        if not self.facility_coords:
            QMessageBox.warning(
                self,
                "No Facility Point",
                "Please pick a facility point before running the analysis.",
            )
            return
        elif not hasattr(self, "aoi_geometry") or self.aoi_geometry is None:
            QMessageBox.warning(
                self,
                "No AOI Polygon",
                "Please draw an area of interest polygon before running the analysis.",
            )
            return

        study_area_coords = qgs_to_coords_list_epsg4326(self.aoi_geometry)

        saw_coords = [
            qgs_to_coords_list_epsg4326(QgsPointXY(pt[0], pt[1]))
            for pt in self.facility_coords
        ]

        tr_s = self.rtSpdSpinBox.value()
        cb_s = self.skylineSpdSpinBox.value()

        tr_d = self.rtSkidderMonSpinBox.value()
        cb_d = self.skylineMonSpinBox.value()
        fb_d = self.fellerbunchRateSpinBox.value()
        hf_d = self.handfellingRateSpinBox.value()
        pr_d = self.processingSpinBox.value()
        ha_d = self.haulingSpinBox.value()
        ht_d = self.handTreatmentSpinBox.value()
        pf_d = self.prescribedFireSpinBox.value()

        tr_p = self.rtSkidderPayloadSpinBox.value()
        cb_p = self.skylinePayloadSpinBox.value()
        lt_p = self.logTruckPayloadSpinBox.value()

        cb_o = self.optionalSurfacesCheckBox.isChecked()

        if self.userRoadsLineEdit.text() == "(Optional)":
            self.lyr_roads_path = None
        if self.userBarriersLineEdit.text() == "(Optional)":
            self.lyr_barriers_path = None
        args = {
            "study_area_coords": study_area_coords,
            "saw_coords": saw_coords,
            "lyr_roads_path": self.lyr_roads_path,
            "lyr_barriers_path": self.lyr_barriers_path,
            "sk_r": tr_s,
            "cb_r": cb_s,
            "sk_d": tr_d,
            "cb_d": cb_d,
            "fb_d": fb_d,
            "hf_d": hf_d,
            "pr_d": pr_d,
            "lt_d": ha_d,
            "ht_d": ht_d,
            "pf_d": pf_d,
            "sk_p": tr_p,
            "cb_p": cb_p,
            "lt_p": lt_p,
            "cb_o": cb_o,
        }
        self.runButton.setEnabled(False)
        self.log_to_textbox("Starting Delivered Cost Analysis...")
        try:
            from .workers import DeliveredCostWorker

            worker = DeliveredCostWorker(args)
            worker.signals.log.connect(self.log_to_textbox)
            worker.signals.progress.connect(self.progressBar.setValue)
            worker.signals.finished.connect(self.handle_results)
            worker.signals.error.connect(self.show_error)
            self.threadpool.start(worker)
        except Exception as e:
            self.log_to_textbox(f"Error initializing worker: {str(e)}")
            self.runButton.setEnabled(True)
            return

    def closeEvent(self, event):
        if hasattr(self, "osm_layer_id") and self.osm_layer_id:
            layer = QgsProject.instance().mapLayer(self.osm_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.osm_layer_id = None
        if hasattr(self, "aoi_layer_id") and self.aoi_layer_id:
            layer = QgsProject.instance().mapLayer(self.aoi_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.aoi_layer_id = None

        if hasattr(self, "draw_polygon_tool") and self.draw_polygon_tool:
            self.draw_polygon_tool.deactivate()

        if hasattr(self, "facility_layer_id") and self.facility_layer_id:
            layer = QgsProject.instance().mapLayer(self.facility_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.facility_layer_id = None
            self.facility_coords = []

        # Switch back to pan tool explicitly
        pan_tool = QgsMapToolPan(iface.mapCanvas())
        iface.mapCanvas().setMapTool(pan_tool)
        for config in self.layer_configs.values():
            layer_id = config.get("layer_id")
            if layer_id:
                layer = QgsProject.instance().mapLayer(layer_id)
                if layer:
                    QgsProject.instance().removeMapLayer(layer)
                    iface.mapCanvas().refresh()
                config["layer_id"] = None
        # Uncheck all checkboxes
        for checkbox in self.layer_configs.keys():
            checkbox.setChecked(False)

        self.userRoadsLineEdit.setText("(Optional)")
        self.userBarriersLineEdit.setText("(Optional)")
        self.closingPlugin.emit()
        event.accept()

    def showEvent(self, event):
        """Override showEvent to add OSM layer when the dock widget is shown."""
        if getattr(self, "osm_layer_id", None) is None:
            self.add_osm_basemap()
            QTimer.singleShot(100, self.zoom_to_us_extent_3857)
        super(DeliveredCostDockWidget, self).showEvent(event)


def qgs_to_coords_list_epsg4326(geom):
    """
    Convert a QgsGeometry or QgsPointXY from project CRS to EPSG:4326 and
    return a list of coordinates.

    For a Point geometry, returns [(lon, lat)].
    For a Polygon geometry, returns a list of (lon, lat) tuples for the exterior ring.

    Parameters:
        geom: QgsGeometry or QgsPointXY

    Returns:
        list of (lon, lat) tuples
    """
    # Get source CRS (usually project CRS)
    src_crs = QgsProject.instance().crs()
    dest_crs = QgsCoordinateReferenceSystem("EPSG:4326")

    # Setup coordinate transformer
    transform = QgsCoordinateTransform(src_crs, dest_crs, QgsProject.instance())

    # If input is QgsPointXY, convert to QgsGeometry first
    if isinstance(geom, QgsPointXY):
        geom = QgsGeometry.fromPointXY(geom)

    # Transform geometry to EPSG:4326
    geom.transform(transform)

    # Convert to shapely geometry via GeoJSON dict
    import json
    from shapely.geometry import shape, Point, Polygon

    geojson_dict = json.loads(geom.asJson())
    shapely_geom = shape(geojson_dict)

    # Extract coordinates depending on geometry type
    if isinstance(shapely_geom, Point):
        # Return list with one coordinate tuple
        return [(shapely_geom.x, shapely_geom.y)]
    elif isinstance(shapely_geom, Polygon):
        # Return list of coords of exterior ring only
        return list(shapely_geom.exterior.coords)
    else:
        # For other geometry types you might want to handle differently
        raise ValueError(f"Unsupported geometry type: {type(shapely_geom)}")


def apply_capped_symbology(raster_layer, cap_value=1000):
    stats = raster_layer.dataProvider().bandStatistics(1)
    actual_min = stats.minimumValue
    symbology_min = actual_min
    symbology_max = cap_value

    # Define color ramp
    ramp_shader = QgsColorRampShader()
    ramp_shader.setColorRampType(QgsColorRampShader.Interpolated)
    ramp_shader.setColorRampItemList(
        [
            QgsColorRampShader.ColorRampItem(
                symbology_min, QColor("red"), str(symbology_min)
            ),
            QgsColorRampShader.ColorRampItem(
                symbology_max * 0.5, QColor("yellow"), str(symbology_max * 0.5)
            ),
            QgsColorRampShader.ColorRampItem(
                symbology_max, QColor("green"), str(f">{symbology_max}")
            ),
        ]
    )
    ramp_shader.setMinimumValue(symbology_min)
    ramp_shader.setMaximumValue(symbology_max)

    # Build shader and renderer
    shader = QgsRasterShader()
    shader.setRasterShaderFunction(ramp_shader)

    renderer = QgsSingleBandPseudoColorRenderer(raster_layer.dataProvider(), 1, shader)

    # Apply renderer
    raster_layer.setRenderer(renderer)

    # Hint to QGIS to use user-defined contrast (sometimes helps retain settings)
    raster_layer.setCustomProperty("contrastEnhancementMinMax", "User")

    raster_layer.triggerRepaint()
