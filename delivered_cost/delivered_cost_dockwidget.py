# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DeliveredCostDockWidget
                                 A QGIS plugin
 This plugin provides delivered cost for an area of interest.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Tim
        email                : timothy.vandriel@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import (
    QgsProject,
    QgsRasterLayer,
    Qgis,
    QgsMessageLog,
    QgsRectangle,
    QgsVectorLayer,
    QgsFeature,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsGeometry,
    QgsPointXY,
    QgsRasterShader,
    QgsColorRampShader,
    QgsSingleBandPseudoColorRenderer,
    QgsRasterBandStats,
    QgsMarkerSymbol,
    QgsWkbTypes,
)
from qgis.gui import QgsMapToolPan, QgsVertexMarker
from qgis.utils import iface
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QInputDialog, QApplication
from PyQt5.QtCore import QTimer, Qt, QThreadPool
from .draw_polygon_tool import DrawPolygonTool
from .pick_point_tool import PickPointTool
from PyQt5.QtGui import QColor


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "delivered_cost_dockwidget_base.ui")
)


class DeliveredCostDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(DeliveredCostDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.threadpool = QThreadPool.globalInstance()
        self.plainTextEdit.setReadOnly(True)
        # Manage the OSM layer
        self.osm_layer_id = None
        QgsProject.instance().layerWillBeRemoved.connect(self.on_layer_removed)
        iface.actionPan().trigger()

        # Background layers
        self.layer_configs = {
            self.esriCheckBox: {
                "name": "ESRI World Imagery",
                "url": "type=xyz&zmin=0&zmax=19&url=https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                "provider": "wms",
                "layer_id": None,
            },
            self.burnProbCheckBox: {
                "name": "Burn Probability",
                "url": "url=https://apps.fs.usda.gov/fsgisx03/rest/services/wo_spf_fam/Nat_BurnProbability/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
            self.evtCheckBox: {
                "name": "EVT",
                "url": "url=https://lfps.usgs.gov/arcgis/rest/services/Landfire_LF230/US_230EVT/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
            self.pctCheckBox: {
                "name": "PCL",
                "url": "url=https://apps.fs.usda.gov/fsgisx03/rest/services/wo_spf_fam/Potential_Control_Location/ImageServer",
                "provider": "arcgismapserver",
                "layer_id": None,
            },
        }

        for checkbox in self.layer_configs.keys():
            checkbox.toggled.connect(self.on_layer_checkbox_toggled)

        # Connect sliders to spinboxes
        self.rtSkidderSpeedSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.rtSkidderSpeedSlider, self.rtSpdSpinBox
            )
        )
        self.rtSpdSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.rtSpdSpinBox, self.rtSkidderSpeedSlider
            )
        )
        self.skylineSpeedSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.skylineSpeedSlider, self.skylineSpdSpinBox
            )
        )
        self.skylineSpdSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.skylineSpdSpinBox, self.skylineSpeedSlider
            )
        )
        self.rtSkidderMonSlider.valueChanged.connect(self.rtSkidderMonSpinBox.setValue)
        self.rtSkidderMonSpinBox.valueChanged.connect(
            lambda val: self.rtSkidderMonSlider.setValue(int(val))
        )

        self.skylineMonSlider.valueChanged.connect(self.skylineMonSpinBox.setValue)
        self.skylineMonSpinBox.valueChanged.connect(
            lambda val: self.skylineMonSlider.setValue(int(val))
        )

        self.fellerbuncherRateSlider.valueChanged.connect(
            self.fellerbunchRateSpinBox.setValue
        )
        self.fellerbunchRateSpinBox.valueChanged.connect(
            lambda val: self.fellerbuncherRateSlider.setValue(int(val))
        )

        self.handFellingSlider.valueChanged.connect(
            self.handfellingRateSpinBox.setValue
        )
        self.handfellingRateSpinBox.valueChanged.connect(
            lambda val: self.handFellingSlider.setValue(int(val))
        )

        self.processingSlider.valueChanged.connect(self.processingSpinBox.setValue)
        self.processingSpinBox.valueChanged.connect(
            lambda val: self.processingSlider.setValue(int(val))
        )

        self.haulingSlider.valueChanged.connect(self.haulingSpinBox.setValue)
        self.haulingSpinBox.valueChanged.connect(
            lambda val: self.haulingSlider.setValue(int(val))
        )

        self.handTreatmentSlider.valueChanged.connect(
            self.handTreatmentSpinBox.setValue
        )
        self.handTreatmentSpinBox.valueChanged.connect(
            lambda val: self.handTreatmentSlider.setValue(int(val))
        )

        self.prescribedFireSlider.valueChanged.connect(
            self.prescribedFireSpinBox.setValue
        )
        self.prescribedFireSpinBox.valueChanged.connect(
            lambda val: self.prescribedFireSlider.setValue(int(val))
        )

        self.rtSkidderPayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.rtSkidderPayloadSlider, self.rtSkidderPayloadSpinBox
            )
        )
        self.rtSkidderPayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.rtSkidderPayloadSpinBox, self.rtSkidderPayloadSlider
            )
        )
        self.skylinePayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.skylinePayloadSlider, self.skylinePayloadSpinBox
            )
        )
        self.skylinePayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.skylinePayloadSpinBox, self.skylinePayloadSlider
            )
        )
        self.logTruckPayloadSlider.valueChanged.connect(
            lambda value: self.update_spinbox_from_slider(
                self.logTruckPayloadSlider, self.logTruckPayloadSpinBox
            )
        )
        self.logTruckPayloadSpinBox.valueChanged.connect(
            lambda value: self.update_slider_from_spinbox(
                self.logTruckPayloadSpinBox, self.logTruckPayloadSlider
            )
        )
        # Initialize AOI and Facility comboboxes
        self.setup_layer_listeners()
        self.populate_layer_comboboxes()

        # Initialize the draw polygon tool
        self.drawTool = DrawPolygonTool(iface.mapCanvas())
        self.drawTool.polygonCompleted.connect(self.handle_polygon_completed)
        self.drawPolygonButton.clicked.connect(self.activate_draw_tool)
        self.aoi_geometry = None  # Store drawn polygon geometry
        self.aoi_layer_id = None  # Store AOI layer ID

        # Initialize pick point tool
        self.pointTool = PickPointTool(iface.mapCanvas())
        self.pointTool.pointPicked.connect(self.handle_point_picked)
        self.pickPointButton.clicked.connect(self.activate_point_picker)
        self.facility_coords = []  # Store picked point coordinates
        self.facility_layer = None
        self.facility_layer_id = None

        # Connect run button
        self.runButton.clicked.connect(self.run_delivered_cost)

    def update_spinbox_from_slider(self, slider, spinbox):
        spinbox.setValue(slider.value() / 10.0)

    def update_slider_from_spinbox(self, spinbox, slider):
        slider.setValue(int(spinbox.value() * 10))

    def add_osm_basemap(self):
        if getattr(self, "osm_layer_id", None) is None:
            layer_name = "OSM Standard"
            url = "type=xyz&zmin=0&zmax=19&url=http://tile.openstreetmap.org/{z}/{x}/{y}.png"
            layer = QgsRasterLayer(url, layer_name, "wms")
            if layer.isValid():
                QgsProject.instance().addMapLayer(layer, addToLegend=False)
                QgsProject.instance().layerTreeRoot().insertLayer(0, layer)
                self.osm_layer_id = (
                    layer.id()
                )  # Store only the layer ID, not the layer object
            else:
                QMessageBox.critical(
                    None,
                    "Layer Load Error",
                    f"Failed to load layer: {layer_name}. Please check the URL.",
                )

    def on_layer_removed(self, layer_id):
        if getattr(self, "osm_layer_id", None) == layer_id:
            self.osm_layer_id = None
        if self.facility_layer_id == layer_id:
            self.facility_layer_id = None
            self.facility_coords = []
            self.facility_layer = None
        if self.aoi_layer_id == layer_id:
            self.aoi_layer_id = None
            self.aoi_geometry = None

    def populate_layer_comboboxes(self):
        self.aoiComboBox.clear()
        self.pointComboBox.clear()
        self.roadsComboBox.clear()
        self.barriersComboBox.clear()
        self.aoiComboBox.addItem("Select AOI Layer or create new", None)
        self.aoiComboBox.setCurrentIndex(0)
        self.pointComboBox.addItem("Select Facility Layer or create new", None)
        self.pointComboBox.setCurrentIndex(0)
        self.roadsComboBox.addItem("Select Roads Layer (Optional)", None)
        self.roadsComboBox.setCurrentIndex(0)
        self.barriersComboBox.addItem("Select Barriers Layer (Optional)", None)
        self.barriersComboBox.setCurrentIndex(0)
        for layer in QgsProject.instance().mapLayers().values():
            if isinstance(layer, QgsVectorLayer):
                self.roadsComboBox.addItem(layer.name(), layer.id())
                self.barriersComboBox.addItem(layer.name(), layer.id())
                geom_type = layer.geometryType()

                if geom_type == QgsWkbTypes.PolygonGeometry:
                    self.aoiComboBox.addItem(layer.name(), layer.id())
                elif geom_type == QgsWkbTypes.PointGeometry:
                    self.pointComboBox.addItem(layer.name(), layer.id())

    def setup_layer_listeners(self):
        QgsProject.instance().layersAdded.connect(self.populate_layer_comboboxes)
        QgsProject.instance().layersRemoved.connect(self.populate_layer_comboboxes)
        QgsProject.instance().layerWasAdded.connect(self.populate_layer_comboboxes)

    def get_selected_aoi_layer(self):
        layer_id = self.aoiComboBox.currentData()
        if layer_id is None:
            return None
        return QgsProject.instance().mapLayer(layer_id)

    def get_selected_aoi_geometry(self):
        aoi_layer = self.get_selected_aoi_layer()
        if aoi_layer is None or not aoi_layer.isValid():
            return None

        # Get the first feature's geometry
        feature = next(aoi_layer.getFeatures())
        self.aoi_geometry = feature.geometry()
        return aoi_layer.crs()

    def get_selected_facility_layer(self):
        layer_id = self.pointComboBox.currentData()
        if layer_id is None:
            return None
        return QgsProject.instance().mapLayer(layer_id)

    def get_selected_facility_coords(self):
        facility_layer = self.get_selected_facility_layer()
        if facility_layer is None or not facility_layer.isValid():
            return None

        # Get all features' geometries
        for feature in facility_layer.getFeatures():
            geom = feature.geometry()
            self.facility_coords.append((geom.asPoint().x(), geom.asPoint().y()))
        return facility_layer.crs()

    def zoom_to_us_extent_3857(self):
        # Approximate extent for continental U.S. in EPSG:3857 (Web Mercator)
        extent_3857 = QgsRectangle(-14000000, 2800000, -7000000, 6300000)

        # Set extent and refresh canvas
        canvas = iface.mapCanvas()
        canvas.setExtent(extent_3857)
        canvas.refresh()

    def on_layer_checkbox_toggled(self, checked):
        checkbox = self.sender()  # Which checkbox sent this signal?
        config = self.layer_configs.get(checkbox)
        if config is None:
            return

        if checked:
            # Add layer if not already added
            if not config["layer_id"]:
                layer = QgsRasterLayer(
                    config["url"], config["name"], config["provider"]
                )
                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    config["layer_id"] = layer.id()
                else:
                    QMessageBox.critical(
                        None,
                        "Layer Load Error",
                        f"Failed to load layer: {config['name']}",
                    )
        else:
            # Remove layer if exists
            layer_id = config.get("layer_id")
            if layer_id:
                layer = QgsProject.instance().mapLayer(layer_id)
                if layer:
                    QgsProject.instance().removeMapLayer(layer)
                    iface.mapCanvas().refresh()
                config["layer_id"] = None

    def activate_draw_tool(self):
        # If AOI layer already exists, remove it from project
        if hasattr(self, "aoi_layer_id") and self.aoi_layer_id:
            layer = QgsProject.instance().mapLayer(self.aoi_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.aoi_layer_id = None
            iface.mapCanvas().refresh()

        # Set up and activate the drawing tool
        iface.mapCanvas().setMapTool(self.drawTool)

        # Show instructions
        iface.messageBar().pushMessage(
            "Instructions for drawing a polygon",
            "Click to add points, right-click to finish the polygon. AOI will be removed if button is clicked again.",
            level=Qgis.Info,
            duration=25,
        )

    def handle_polygon_completed(self, geom):
        project_crs = QgsProject.instance().crs()
        geom = QgsGeometry(geom)
        self.aoi_geometry = geom

        # Create the layer
        aoi_layer = QgsVectorLayer(
            f"Polygon?crs={project_crs.authid()}", "AOI", "memory"
        )
        QgsProject.instance().addMapLayer(aoi_layer)
        self.aoi_layer_id = aoi_layer.id()  # Store only the ID

        pr = aoi_layer.dataProvider()
        feat = QgsFeature()
        feat.setGeometry(geom)
        pr.addFeatures([feat])
        aoi_layer.updateExtents()
        aoi_layer.triggerRepaint()
        iface.mapCanvas().refresh()

        iface.actionPan().trigger()

    def activate_point_picker(self):
        if self.facility_layer is None:
            # Create a memory layer for facility points
            crs = QgsProject.instance().crs()
            self.facility_layer = QgsVectorLayer(
                f"Point?crs={crs.authid()}", "Facilities", "memory"
            )
            QgsProject.instance().addMapLayer(self.facility_layer)
            self.facility_layer_id = self.facility_layer.id()

            # Apply black dot symbology
            symbol = QgsMarkerSymbol.createSimple(
                {
                    "name": "cross_fill",
                    "color": "black",
                    "size": "2",
                }
            )
            self.facility_layer.renderer().setSymbol(symbol)
            self.facility_layer.triggerRepaint()

        iface.mapCanvas().setMapTool(self.pointTool)

        iface.messageBar().pushMessage(
            "Instructions for picking multiple points",
            "Click to add a facility location. Repeat as needed. Delete 'Facilities' layer to start over.",
            level=Qgis.Info,
            duration=20,
        )

    def handle_point_picked(self, point):
        self.facility_coords.append((point.x(), point.y()))
        geom = QgsGeometry.fromPointXY(point)

        # Add the new point to the same memory layer
        provider = self.facility_layer.dataProvider()
        feat = QgsFeature()
        feat.setGeometry(geom)
        provider.addFeatures([feat])
        self.facility_layer.updateExtents()
        self.facility_layer.triggerRepaint()
        iface.mapCanvas().refresh()

    def log_to_textbox(self, message):
        self.plainTextEdit.appendPlainText(str(message))

    def handle_results(self, result_dict):

        self.log_to_textbox("Delivered Cost Analysis completed successfully.")
        self.runButton.setEnabled(True)
        try:
            for name, dest_path in result_dict.items():
                layer = QgsRasterLayer(dest_path, name)
                layer.setCustomProperty("delivered_cost_plugin/temp", True)

                # Ensure the raster layer is valid
                if not layer.isValid():
                    raise RuntimeError("Raster layer failed to load.")

                # Trigger stats computation so QGIS knows actual min/max values
                provider = layer.dataProvider()
                stats = provider.bandStatistics(1, QgsRasterBandStats.All)
                min_val = stats.minimumValue
                max_val = stats.maximumValue

                # Now apply symbology AFTER stats are known
                if (
                    "delivered" in name.lower()
                    or "skidder" in name.lower()
                    or "cable" in name.lower()
                ):
                    if max_val > 1000:
                        self.log_to_textbox(
                            f"Applying capped symbology to {name} with max value 1000"
                        )
                        apply_capped_symbology(layer, cap_value=1000)
                    else:
                        self.log_to_textbox(
                            f"Applying uncapped symbology to {name} with max value {max_val}"
                        )
                        apply_capped_symbology(layer, cap_value=max_val)

                QgsProject.instance().addMapLayer(layer)
        except Exception as e:
            self.log_to_textbox(f"Error adding layers to project: {str(e)}")

    def show_error(self, error_message):
        self.log_to_textbox(f"Error: {error_message}")
        QMessageBox.critical(self, "Error", error_message)
        self.runButton.setEnabled(True)

    def run_delivered_cost(self):
        self.plainTextEdit.clear()
        aoi_crs = self.get_selected_aoi_geometry()
        print(self.aoi_geometry)
        if aoi_crs is None:
            study_area_coords = qgs_to_coords_list_epsg4326(self.aoi_geometry)
        else:
            study_area_coords = qgs_to_coords_list_epsg4326(
                self.aoi_geometry, source_crs=aoi_crs
            )

        facility_crs = self.get_selected_facility_coords()
        print(self.facility_coords)
        if facility_crs is None:
            saw_coords = [
                qgs_to_coords_list_epsg4326(QgsPointXY(pt[0], pt[1]))
                for pt in self.facility_coords
            ]
        else:
            saw_coords = [
                qgs_to_coords_list_epsg4326(
                    QgsPointXY(pt[0], pt[1]), source_crs=facility_crs
                )
                for pt in self.facility_coords
            ]
        print("Facility Coords:", self.facility_coords)
        print("AOI Geometry:", self.aoi_geometry)
        if not self.facility_coords:
            QMessageBox.warning(
                self,
                "No Facility Point",
                "Please pick a facility point before running the analysis.",
            )
            return
        elif not hasattr(self, "aoi_geometry") or self.aoi_geometry is None:
            QMessageBox.warning(
                self,
                "No AOI Polygon",
                "Please draw an area of interest polygon before running the analysis.",
            )
            return
        if self.roadsComboBox.currentData() is not None:
            layer = QgsProject.instance().mapLayer(self.roadsComboBox.currentData())
            if layer_has_speed_field(layer):
                self.lyr_roads_path = layer.source()
            else:
                QMessageBox.warning(
                    self,
                    "Invalid Roads Layer",
                    "The selected roads layer does not have a 'speed' field. Please select a valid roads layer.",
                )
                return
        else:
            self.lyr_roads_path = None
        if self.barriersComboBox.currentData() is not None:
            layer = QgsProject.instance().mapLayer(self.barriersComboBox.currentData())
            self.lyr_barriers_path = layer.source()
        else:
            self.lyr_barriers_path = None

        tr_s = self.rtSpdSpinBox.value()
        cb_s = self.skylineSpdSpinBox.value()

        tr_d = self.rtSkidderMonSpinBox.value()
        cb_d = self.skylineMonSpinBox.value()
        fb_d = self.fellerbunchRateSpinBox.value()
        hf_d = self.handfellingRateSpinBox.value()
        pr_d = self.processingSpinBox.value()
        ha_d = self.haulingSpinBox.value()
        ht_d = self.handTreatmentSpinBox.value()
        pf_d = self.prescribedFireSpinBox.value()

        tr_p = self.rtSkidderPayloadSpinBox.value()
        cb_p = self.skylinePayloadSpinBox.value()
        lt_p = self.logTruckPayloadSpinBox.value()

        cb_o = self.optionalSurfacesCheckBox.isChecked()
        args = {
            "study_area_coords": study_area_coords,
            "saw_coords": saw_coords,
            "lyr_roads_path": self.lyr_roads_path,
            "lyr_barriers_path": self.lyr_barriers_path,
            "sk_r": tr_s,
            "cb_r": cb_s,
            "sk_d": tr_d,
            "cb_d": cb_d,
            "fb_d": fb_d,
            "hf_d": hf_d,
            "pr_d": pr_d,
            "lt_d": ha_d,
            "ht_d": ht_d,
            "pf_d": pf_d,
            "sk_p": tr_p,
            "cb_p": cb_p,
            "lt_p": lt_p,
            "cb_o": cb_o,
        }
        self.runButton.setEnabled(False)
        self.log_to_textbox("Starting Delivered Cost Analysis...")
        try:
            from .workers import DeliveredCostWorker

            worker = DeliveredCostWorker(args)
            worker.signals.log.connect(self.log_to_textbox)
            worker.signals.progress.connect(self.progressBar.setValue)
            worker.signals.finished.connect(self.handle_results)
            worker.signals.error.connect(self.show_error)
            self.threadpool.start(worker)
            self.facility_coords = []  # Reset after running
            self.aoi_geometry = None  # Reset after running
            self.aoi_layer_id = None  # Reset after running
            self.facility_layer_id = None  # Reset after running
            self.facility_layer = None  # Reset after running
            self.lyr_barriers_path = None  # Reset after running
            self.lyr_roads_path = None  # Reset after running

        except Exception as e:
            self.log_to_textbox(f"Error initializing worker: {str(e)}")
            self.runButton.setEnabled(True)
            return

    def closeEvent(self, event):
        self.facility_coords = []
        self.aoi_geometry = None
        if hasattr(self, "osm_layer_id") and self.osm_layer_id:
            layer = QgsProject.instance().mapLayer(self.osm_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.osm_layer_id = None
        if hasattr(self, "aoi_layer_id") and self.aoi_layer_id:
            layer = QgsProject.instance().mapLayer(self.aoi_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.aoi_layer_id = None

        if hasattr(self, "facility_layer_id") and self.facility_layer_id:
            layer = QgsProject.instance().mapLayer(self.facility_layer_id)
            if layer:
                QgsProject.instance().removeMapLayer(layer)
            self.facility_layer_id = None

        if hasattr(self, "draw_polygon_tool") and self.draw_polygon_tool:
            self.draw_polygon_tool.deactivate()

        if hasattr(self, "pointTool") and self.pointTool:
            self.pointTool.deactivate()

        # Switch back to pan tool explicitly
        pan_tool = QgsMapToolPan(iface.mapCanvas())
        iface.mapCanvas().setMapTool(pan_tool)
        for config in self.layer_configs.values():
            layer_id = config.get("layer_id")
            if layer_id:
                layer = QgsProject.instance().mapLayer(layer_id)
                if layer:
                    QgsProject.instance().removeMapLayer(layer)
                    iface.mapCanvas().refresh()
                config["layer_id"] = None
        # Uncheck all checkboxes
        for checkbox in self.layer_configs.keys():
            checkbox.setChecked(False)

        self.closingPlugin.emit()
        event.accept()

    def showEvent(self, event):
        """Override showEvent to add OSM layer when the dock widget is shown."""
        if getattr(self, "osm_layer_id", None) is None:
            self.add_osm_basemap()
            QTimer.singleShot(100, self.zoom_to_us_extent_3857)
        super(DeliveredCostDockWidget, self).showEvent(event)


def qgs_to_coords_list_epsg4326(geom, source_crs=None):
    """
    Convert a QgsGeometry or QgsPointXY from project CRS to EPSG:4326 and
    return a list of coordinates.

    For a Point geometry, returns [(lon, lat)].
    For a Polygon geometry, returns a list of (lon, lat) tuples for the exterior ring.

    Parameters:
        geom: QgsGeometry or QgsPointXY

    Returns:
        list of (lon, lat) tuples
    """
    # Get source CRS (usually project CRS)
    print("Source CRS:", source_crs)
    if source_crs is None:
        src_crs = QgsProject.instance().crs()
    else:
        src_crs = source_crs
    dest_crs = QgsCoordinateReferenceSystem("EPSG:4326")

    # Setup coordinate transformer
    transform = QgsCoordinateTransform(src_crs, dest_crs, QgsProject.instance())

    # If input is QgsPointXY, convert to QgsGeometry first
    if isinstance(geom, QgsPointXY):
        geom = QgsGeometry.fromPointXY(geom)

    # Transform geometry to EPSG:4326
    if src_crs != dest_crs:
        print("Transforming geometry from", src_crs.authid(), "to", dest_crs.authid())
        geom = geom.transform(transform)

    # Convert to shapely geometry via GeoJSON dict
    import json
    from shapely.geometry import shape, Point, Polygon, MultiPolygon

    geojson_dict = json.loads(geom.asJson())
    shapely_geom = shape(geojson_dict)

    if isinstance(shapely_geom, Point):
        return [(shapely_geom.x, shapely_geom.y)]
    elif isinstance(shapely_geom, Polygon):
        return list(shapely_geom.exterior.coords)
    elif isinstance(shapely_geom, MultiPolygon):
        # Take only the first polygon for simplicity
        return list(shapely_geom.geoms[0].exterior.coords)
    else:
        raise ValueError(f"Unsupported geometry type: {type(shapely_geom)}")


def apply_capped_symbology(raster_layer, cap_value=1000):
    stats = raster_layer.dataProvider().bandStatistics(1)
    actual_min = stats.minimumValue
    symbology_min = actual_min
    symbology_max = cap_value

    # Define color ramp
    ramp_shader = QgsColorRampShader()
    ramp_shader.setColorRampType(QgsColorRampShader.Interpolated)
    ramp_shader.setColorRampItemList(
        [
            QgsColorRampShader.ColorRampItem(
                symbology_min, QColor("red"), str(symbology_min)
            ),
            QgsColorRampShader.ColorRampItem(
                symbology_max * 0.5, QColor("yellow"), str(symbology_max * 0.5)
            ),
            QgsColorRampShader.ColorRampItem(
                symbology_max, QColor("green"), str(f">{symbology_max}")
            ),
        ]
    )
    ramp_shader.setMinimumValue(symbology_min)
    ramp_shader.setMaximumValue(symbology_max)

    # Build shader and renderer
    shader = QgsRasterShader()
    shader.setRasterShaderFunction(ramp_shader)

    renderer = QgsSingleBandPseudoColorRenderer(raster_layer.dataProvider(), 1, shader)

    # Apply renderer
    raster_layer.setRenderer(renderer)

    # Hint to QGIS to use user-defined contrast (sometimes helps retain settings)
    raster_layer.setCustomProperty("contrastEnhancementMinMax", "User")

    raster_layer.triggerRepaint()


def layer_has_speed_field(layer: QgsVectorLayer) -> bool:
    return "speed" in [f.name().lower() for f in layer.fields()]
